# OS-Concept

운영체제를 공부한 내용을 공유합니다. 

이 레포의 목적은 정확한 지식이 아닙니다. OS를 공부하고 싶은데 공룡책을 봐도봐도 이해하기 어려운, 초보 OR 비전공자 친구를 위한 레포입니다. 그리고 이 친구들이 **감을 잡게 하는데 목적이 있습니다.**

내맘대로 재해석해서 옮깁니다. 오류가 있을 수 있습니다. 이슈를 남겨 주세요. :heart:

# 목차

1. [About OS](#about-os)
2. [컴퓨터 시스템 구조](#computer-system)
   - [CPU](#cpu)
     - [Instruction](#instruction)
     - [Register](#register)
     - [Mode Bit](#mode-bit)
     - [System Call](#system-call)
     - [Program Counter](#program-counter)
     - [Context Switching](#context-switching)
     - [Interrupt](#interrupt)
3. [프로세스](#프로세스)
   - [프로세스는?](#프로세스는)
   - [Process Status](#프로세스의-상태)
   - [Process Memory Structure](#프로세스-메모리-구조)
   - [Thread](#thread)
   - [Process Control Block (PCB)](#pcb)
4. [CPU 스케줄링](#cpu-스케줄링)
   1. 선점과 비선점 preemptive vs non-preemptive
   2. Scheduling Criteria
      - CPU Utilization
      - Throughput
      - Turnaround Time
      - Waiting Time
      - Response Time
   3. 스케줄링 종류
      - FCFS
      - SJF
      - Priority
      - Round Robin (RR)
      - Multilevel Queue
      - Multilevel Feedback Queue
5. 프로세스 - 동기화
   1. 다중작업
      - MultiProcess (IPC)
        - Message Passing
        - Shared Memory
   2. 문제
      - Race Condition
      - Cirtical Section
      - Kernel Race Condition

6. 메모리 관리
   1. Logical Address vs Physical Address
   2. Dynamic Loading
       1. Paging
       2. Segmentation
       3. Paging and Segmetation
7. 가상 메모리
8. 파일 시스템
9.  

....



## About OS
![os-image](assets/Operating_system_placement_kor.png)


### 운영체제

운영체제는 컴퓨터 하드웨어와 사용자를 연결해주는 소프트웨어다. 컴퓨터에 대한 모든 소프트웨어적 행동은 운영체제를 경유해 하드웨어를 사용하게 된다.

사용자와 사용자 프로세스는 운영체제가 있어야만 CPU, 메모리, 하드디스크 등 하드웨어(컴퓨터)에 접근할 수 있다. 때문에 켜져 있는 컴퓨터에서는 운영체제가 항상 메모리에 상주하고 있다. 부지런히 자원을 관리하고 사용자의 요청을 처리한다.

운영체제의 가장 큰 관심사는 자원의 효율적 관리다. 유한한 하드웨어와 유한한 성능을 가지고 최대한의 퍼포먼스를 내는 것이다. 더해서 컴퓨터 시스템을 보호하고 사용자와 운영체제 자신을 보호하는데도 목적이 있다.

잠깐, `자원`의 `효율적` `관리` 라고? 다른 분야에서도 관심있는 키워드다. 비즈니스에 OS를 대입해 보자.

집게사장을 상상해보자. 집게사장은 집게리아의 사장이다. 최저시급을 주고 깐깐징어를 고용했다. 깐깐징어는 집게리아에서 햄버거를 만드는 역할을 한다. 깐깐징어는 재료를 가져다 햄버거 만드는 일을 한다.

집게리아에는 여러 햄버거 메뉴가 있다. 각 햄버거를 만들기 위해서는 빵과 게살, 특별 재료, 소스가 필요하다. 지하 창고에 재료들이 보관되어 있다. 깐깐징어에게는 시간당 월급을 주어야 한다. 욕심 많은 집게사장은 집게리아를 어떻게 운영해야 갑부가 될 수 있을까?

깐깐징어에게 쉼없이 일을 시킨다. 펑펑 놀면서 월급을 받는 꼴을 보면 집게사장은 속이 터질 것 같다. 뭐라도 시켜야 한다. 그렇다고 게살버거를 주문했는데 새우버거를 만들면 안된다. 깐깐징어는 상황에 따라 적절한 일을 해야 한다.

냉장고에는 적절한 재료를 준비해둔다. 멍청한 깐깐징어가 햄버거를 만들 때마다 지하 창고에 내려가면 햄버거 만드는 시간이 너무 오래 걸린다. 한번에 적절한 재료를 냉장고에 넣어 두어야 한다. 같은 햄버거 10개를 만들 때는 10개치 재료를 냉장고에서 꺼내와 가까이 두면 햄버거를 더 빨리 만들 수 있다.

깐깐징어가 불쌍하지만 집게사장은 운영(경영)을 잘해서 갑부가 되었다고 한다...

운영체제도 집게사장과 거의 비슷하다. 가장 비싼 자원인 CPU를 놀리지 않게 한다. 유한한 메모리를 적절히 관리하기 위해서 무엇을 메모리에 올려둘지 제어한다. 하드디스크에 무엇을 어디에 어떻게 저장할지 결정한다. 그리고 이것은 비단 컴퓨터 뿐 아니라 일상생활에서 어느 정도 활용할 수 있다. ~~불쌍한 깐깐징어~~

굳이 집게사장 비유를 든 것도 마찬가지다. 충분히 일상생활에서 있을만한 문제를, 전산학적으로 접근할 뿐이다. OS가 마주한 문제들에 공감하기 시작하면 의외로 쉽게 이해가 가능하다.

### 운영체제의 분류

여러 분류 기준에 따라 운영체제를 나눌 수 있다.

1. 동시작업 가능?
   - 단일 작업 - MS-DOS
   - 다중 작업 - 현대 OS
2. 단일 사용자?
   - 단일 사용자 - Window 
   - 다중 사용자 - UNIX, Linux
3. 처리 방식?
   - 모아서 한방에! Batch
   - 실시간으로 처리! RealTime
   - 시분할 Time Sharing. 현대 OS

### 주요 관심사

**좋은** 운영체제를 위한 문제들이다. 하드웨어 매니징이 가능하면 모두 OS라 부를 수 있겠지만, 다음 문제들을 잘 풀어내야 **좋은 운영체제**가 될 수 있다. 아래 문제를 설명하고 해법을 제시하는게 OS책의 대부분 내용이다.

- CPU 스케줄링
- 프로세스 관리
- 메모리 관리
- 파일 관리
- IO 관리
- 시스템 보호
- 네트워크



## Computer System

![system](assets/computer-system.png)

### 줄거리

동시에 일어나는 여러 일들을 한번에 이해하기 어려울 수 있다. 세부 항목을 읽으면서 다시 돌아와 그림을 보는게 좋다.

위 구조는 현대 컴퓨터 시스템을 나타낸다. 멀티 태스킹을 지원하는 Time Sharing 방식의 OS가 위 시스템을 제어한다. Interrupt Driven IO라고도 불리는 비동기식 입출력을 사용한다.

CPU와 메모리가 상호작용하면서 작업(프로세스A)을 실행한다. CPU는 메모리에 있는 프로세스의 실행 정보를 Register(캐시는 생략..)에 불러온다. CPU는 Register에 있는 Instruction을 실행한다.

CPU는 Instruction을 실행할 때마다 Program Counter를 변경시킨다. 

Timer로 부터 Interruption이 발생했다. CPU는 다음 명령을 실행하기 전에 Interruption을 확인했다. 다음 동작을 그만두고 운영체제에 어떻게 할지 물어본다.(Interrupt Handler) CPU는 운영체제가 시키는 대로 다음 작업(프로세스B)을 실행한다.

프로세스B가 운영체제로부터 파일을 읽어달라고 요청했다. 운영체제는 Device Controller에게 명령을 전달하고 CPU는 그동안 다른 작업(프로세스C)을 실행하게 한다. 파일 읽기가 끝나면 Device Controller는 Interrupt를 발생시키거나,  Direct Memory Access을 통해 읽은 내용을 메모리에 전달한다. 

-반복-

뭔 소리래? ...



### CPU

#### Instruction

CPU 명령 집합을 Instruction이라고 부른다. 모든 프로그래밍 언어는 실행시 기계어로 바뀐다. 즉, CPU가 이해할 수 있는 Instruction으로 바꾸어 CPU가 처리하도록 한다. 기계어로 바뀌는 과정에 따라 컴파일 언어, 인터프리터 언어로 구분할 뿐이다.

CPU가 실행하는 Instruction은 비트연산이다. 1 + 2를 수행하려면 메모리로부터 1을 불러오고 2를 불러온 다음, 비트연산으로 덧셈 결과를 계산한다. 마지막으로 계산 결과를 저장한다. CPU는 모든 작업을 이렇게 단순한 명령 집합으로 처리한다.  
하나 짚어야 할 것은 CPU의 실행 모드(Mode Bit)에 따라 실행할 수 있는 Instruction이 다르다는 것이다. 커널모드(Mode Bit 0)에서는 모든 Instruction을 실행할 수 있고 유저 모드(Mode Bit 1)에서는 일부 Instruction만 가능하다.  
예컨대 유저 모드 상태로 파일시스템에 접근(생성, 읽기, 쓰기, 삭제)할 수 없다. 즉, Mode Bit이 1인 상태에서 파일 접근 명령을 수행할 수 없다는 뜻이다. 파일시스템은 운영체제만 접근 가능하다. 즉, Mode Bit이 0일때에만 파일 접근 명령을 수행할 수 있다. 그래서 유저 프로세스는 운영체제에 파일에 대한 작업을 **요청**한다.

얼마전 이슈가 되었던 인텔 CPU의 멜트다운도 이 맥락에서 이해가 가능하다. 원래 유저는 커널모드의 Instruction을 실행할 수 없다. 그러나 CPU 실행 중에 간접적으로 커널 영역의 값을 알아낼 수 있는 방법이 알려졌고, 멜트다운으로 명명되었다. 자세한 내용은 구글에 검색하면 잘 나온다. 보다보면 CPU 동작 방식을 유추해 볼 수 있다. 캐시, 레지스터, 커널 등이 언급된다.

#### Register

레지스터, Cache(캐시), 메모리, SSD, HDD, CD... 모두 저장 장치다. 0과 1로 이루어진 이진 정보를 보관하는 역할을 한다. 순서대로 레지스터가 가장 빠르고 CD가 가장 느리다. CPU는 모든 저장장치보다 처리 속도가 빠르다. CPU를 효율적으로 사용하려면 빠른 저장장치를 CPU에 가까이 두어야 한다. 자연히 레지스터가 CPU와 가장 가깝고 CD가 CPU와 가장 멀다. CPU와 상호작용할 수 있을 만큼 빠른 것들은 메모리까지다. HDD이하는 CPU와 직접 상호작용하기에 너무 느리다. HDD의 데이터는 속도가 빠른 임시 저장장치, 메모리 캐시 레지스터에 옮겨져 CPU와 상호작용하게 된다.  
이를 메모리 계층구조(Memory Hierarchy)이라 부른다. 다 같은 저장장치지만 속도와 쓰임새가 다르다.

레지스터와 Cache는 CPU 안에 있는 저장장치다. 가장 빠르다. 빠른 축에 속한 RAM보다 훨씬 빠르다. 그래서 RAM보다 빠른 레지스터를 CPU가까이 두고 CPU가 전용으로 쓰도록 한다.

메모리 계층에 관한 유튜브 영상.

[![youtube](https://img.youtube.com/vi/Vj2rNQFvdDw/0.jpg)](https://youtu.be/Vj2rNQFvdDw)

#### Mode Bit

0과 1로만 구성된 특별한 비트다. 0은 커널모드, 1은 유저모드를 의미한다. CPU는 자신이 처리해야 할 명령을 메모리(프로세스)로부터 받는다. CPU는 스스로 처리해야 할 Instruction이 적절한지 Mode Bit을 보고 판단한다. Mode Bit이 1이면 파일시스템 접근 Instruction을 실행할 수 없음을 인지하고 운영체제에 이 사실을 일러버린다. 운영체제는 프로세스를 참교육(Abort)시킨다.

그럼 프로세스는 파일 시스템에 직접 접근할 수 없나? 없다. 진짜 없다. 대신 커널을 통해서 접근할 수 있다. 프로세스가 커널에게 "A파일 정보를 주세요"라고 부탁한다. 커널은 요청을 검사하고(유저가 권한이 없거나... chmod를 상상해보라) 문제가 없으면 CPU에게 파일을 읽게 한다. 파일읽기가 끝나면 커널이 프로세스에게 파일정보를 넘겨준다.

#### System Call

유저 프로세스가 커널에게 "부탁" 하는 것을 "시스템 콜"이라고 부른다. 모든 프로그램은 CPU, 메모리, IO장치들이 필요하다. C언어에서 `printf("Hello World");`를 작성하면 모니터에 헬로월드가 출력된다. 이 동작을 위해선 CPU가 메모리로부터 데이터를 읽고 문자열을 처리하고 모니터에 "Hell World"를 출력하라는 명령을 내려야 한다. 코드에 이렇게 하드웨어를 직접 제어하는 부분이 있는가? 없다. 유저가 하드웨어를 직접 접근하지 않고도 하드웨어를 사용할 수 있도록, 운영체제가 유저 프로그램의 요청을 하드웨어가 처리하도록 해준다. 운영체제는 하드웨어를 제어하는 명령을 시스템 콜 형식으로 유저에게 개방한다. 즉 시스템 콜은 하드웨어, 시스템에 대한 **인터페이스**다.

![시스템콜](https://user-images.githubusercontent.com/40727649/68071678-028f3a80-fdc0-11e9-8422-1a74d70b7e39.PNG)

유저 프로세스가 시스템 콜을 호출하면 커널이 작업을 수행하고 결과를 유저 프로세스에 넘겨준다. 커널이 프로세스에게 무언가를 넘겨주는 것에 주목해보자. 프로세스끼리는 서로 알지 못한다. 서로 독립적인 메모리 영역을 갖고 있기 때문이다. 커널 역시 프로세스 내부 모두를 알 수 없다. 프로세스 정보를 보관해 둘 뿐, 프로세스 메모리 영역 모두를 알고 있진 않다. 하지만 프로세스 사이에서 데이터를 넘겨줄수 있다. 이런 동작들을 `Communication`이라고 부른다. 커널은 프로세스에 관한 정보를 알고 있으므로 A프로세스와 B프로세스 사이에서 데이터를 전달해 줄수 있다. 이렇게 프로세스간 통신을 Inter Process Communication(IPC)라고 부르고 커널을 통한 전달 방식을 Message Passing이라고 부른다.  
네트워크 역시 Communication이다. 다른 호스트들에 데이터를 주고 받는다. 운영체제는 Communication을 위한 여러 인터페이스를 제공한다.

#### Program Counter

멀티 태스킹하는 스스로를 생각해보자. 책을 읽다가 전화가 왔다. 책 읽기를 잠시 멈추고 전화를 받는다. 통화가 끝나고 다시 책을 읽는다. 어디부터? 마지막까지 읽은 곳부터. 컴퓨터는 "책의 마지막까지 읽은 곳"을 Program Counter에 기록한다.

다중 작업을 지원하는 운영체제에서는 어떤 작업이 CPU를 사용하다 언제든지 뺏길 수 있다. 문제는 언제 뺏길지 아무도 알 수 없는(예측할 수 없는) 상황이다. 언제 전화가 올지 모르는 것처럼. 언제 CPU를 뺏기는지 예측이 가능하다면 미리 저장해 두면 될 텐데, 그럴 수 없다는 뜻이다. 그럼 뺏겼다가 다시 찾아왔을 때, 어디까지 실행했는지 정보는 어떻게 해야 할까? 

운영체제는 프로세스 실행의 맥락(Context)를 보관해야 할 필요가 있다. 그러나 프로세스가 실행 중일때(유저 모드일때) 일어나는 상황은 운영체제도 모른다. (유저 프로세스가 CPU를 사용중이므로 == 커널이 CPU를 사용하고 있지 않으므로) 그래서 CPU가 하드웨어적으로 Context를 기록하게 한다. 이게 Program Counter다. CPU는 Instruction을 실행할 때마다 Program Counter를 변경한다. Program Counter가 가리키는 것은 해당 프로세스의 Instruction 메모리 주소다. CPU를 차지하는 작업이 바뀔 때마다 CPU는 운영체제에 Program Counter를 보고한다. 운영체제는 프로세스들의 Program Counter를 기록해 둔다. 프로세스가 재실행될 때 Program Counter를 같이 전달해서 직전 실행에 이어서 실행할 수 있게 한다. 

#### Context Switching

실행중인 프로세스를 중단하고 다른 프로세스를 실행시키기 위해 맥락을 바꾸는 것을 Context Switching이라고 한다. 운영체제 책을 읽다가 친구로부터 걸려온 전화를 받으려면 생각을 바꿔야 한다. 친구에게 커널이 어쩌고 저쩌고 하면 안된다(?). 마찬가지로 책을 읽을 때 친구와 뭐 먹지 생각하면 안된다. 비슷하게, 작업에 따라 CPU는 실행흐름을 바꿔야 한다.  
Context Switching은 비용이 큰 작업이다. 이전까지 하던 모든 것을 잊고(캐시와 레지스터를 비우고) 새로 할 작업을 준비(메모리로부터 캐시와 레지스터를 채우는)하기 때문이다. 그렇다고 프로세스를 바꿔주지 않으면 동시 작업이 불가능하다. 즉, 효율을 따지면 멀티태스킹을 하기 어렵고 멀티태스킹 하자니 효율이 떨어진다. 자주 바꾸면 더 많은 작업을 동시에 할 수 있지만, 각 작업당 Context Switching 비용이 커져서 작업 효율이 나지 않는다. 작업을 바꾸지 않으면 한 작업에 대해서는 효율적으로 할 수 있지만 동시에 여러 작업을 수행하지 못한다. 이처럼 어떻게 적절히 프로세스를 실행시킬 것인지에 대한 이슈를 다루는 단원이 CPU 스케줄링이다.

#### Interrupt

멀티태스킹을 가능하게 하는 핵심적인 요소다. 문자 그대로 CPU를 방해한다. CPU는 한 명령이 끝나면 Interrupt Line을 검사한다. Interrupt가 없으면 다음 명령을 실행하고 있으면 Mode Bit을 0으로 바꾼뒤 (커널모드) 커널을 실행한다. 커널은 Interrupt Handler Routine 인터럽트 핸들러를 갖고 있다. 커널은 나름대로의 알고리즘으로 다음에 무엇을 어떻게 처리할지 알고 있다. 다음 프로세스가 결정되면 커널은 Mode Bit을 1로 바꾸고 다음 작업을 실행하도록 한다.

Interrupt는 두가지 요소가 발생시킨다.

1. Timer

커널은 유저 프로세스에게 CPU를 할당해 주면서 CPU 사용 시간도 같이 할당한다. 즉 유저 프로세스가 실행되는 시간을 제한한다. 커널은 유저 프로세스를 실행시키면서 Timer 하드웨어에 시간을 입력한다. Timer는 시간이 되면 Interrupt를 발생시킨다. 유저 프로세스는 작업을 다 마치지 않았더라도 CPU로부터 쫓겨난다.

어디서 많이 본 느낌이다. 자바스크립트 비동기 동작 방식과 매우 유사하다. 콜스택에서 브라우저 API를 호출하고 타이머에 달아뒀다가 다시 콜스택에 옮기는 일련의 과정. Interrupt를 통한 강제적 점유 빼고 매우 흡사하다.

2. IO 컨트롤러

CPU는 무지하게 빠르다. 상대적으로 느린(백만배 이상 느린) IO장치를 넋놓고 기다리기엔 운영체제가 호락호락하지 않다. IO이 끝날 때까지 운영체제는 CPU가 기다리지 않고 다른 일을 하도록 한다. IO이 끝나면, IO를 요청한 프로세스가 이어서 실행될 수 있어야 한다. 각 Device Controller는 IO이 끝난 것을 Interrupt를 발생시켜 알린다. 

그러나 너무 자주 Interrupt를 발생시키면 비효율적(Context Switching)이므로 Interrupt를 발생시키지 않고 바로 메모리에 로드할 수도 있다. 이를 관장하는게 Direct Memory Access다.




## 프로세스

운영체제는 A프로그램을 실행할 것을 요청받았다. 커널은 A프로그램 코드가 저장된 하드 디스크에서 데이터를 읽어서 메모리의 특정 영역으로 불러들이고 87프로세스로 이름붙인다. 87프로세스는 CPU를 사용하기 위해 기다린다. 차례가 되면 CPU가 87프로세스의 코드를 실행한다. ... 87프로세스가 끝나면 메모리에서 87프로세스 내용을 치운다.


### 프로세스는?

앞서 **프로세스**라는 용어를 자주 썼다. 무슨 의미인지 대략 알 수 있을 것이다. 

위키백과에서는 다음과 같이 설명하고 있다.

> 프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.
>
> 프로그램은 일반적으로 하드 디스크 등에 저장되어 있는 실행코드를 뜻하고, 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.

여기서 알 수 있는 프로세스의 특징은

1. 프로세스는 메모리에 있다.
2. 프로세스에는 "시간" 또는 "순서" 개념이 있다.  _~ 연속적으로 실행되고 있는 프로그램 ~_
3. **프로세스는 독립적인 메모리 공간**을 갖고 있다.

### 프로세스의 상태

프로세스는 다음에 해당하는 상태를 단 하나만 가질 수 있다. 다음에 해당하지 않는 상태를 갖는 프로세스는 존재하지 않는다.
![프로세스_상태](https://user-images.githubusercontent.com/40727649/68071678-028f3a80-fdc0-11e9-8422-1a74d70b7e39.PNG)

- NEW : 새로 생성중인 상태. 프로그램 정보가 디스크로부터 메모리로 데이터가 이동하거나 완료된 상태다. _이 과정을 Dispatch라고 한다_
- READY : 실행 대기중인 상태. CPU를 사용하고 있지 않지만 언제든지 CPU를 사용할 가능성이 있다.
- RUNNING : 실행중인 상태. CPU를 사용하고 있다.
- WAITING : 특정 이벤트를 기다리는 상태. IO를 요청하는 등의 이유로 CPU를 사용해봤자 진행이 안되는 경우다.
- TERMINATED : 종료된 프로세스. 메모리에서 제거된다.

### 프로세스 메모리 구조

![프로세스](/assets/slide_1.jpg)

> 이미지 출처: https://slideplayer.com/slide/6168452/

프로세스는 크게 Code, Data, Stack 영역으로 구분할 수 있다. 

- Code 영역엔 CPU가 실행할 명령들이 있다. 예) 변수 A에 10을 넣어라. 변수 B에 변수 A + 10을 넣어라. ...
- Data 영역엔 전역변수나 Object가 존재한다. 예) 메서드, static 변수, 글로벌 변수 ...
- Stack 영역엔 지역변수, 매개변수, 리턴값 등 임시적으로 쓰는 데이터가 존재한다. 

프로세스가 생성될 때, Code영역에 모든 코드가 저장된다. Code 영역은 **변하지 않는다.**  
Data, Stack은 실행하면서 내용이 **바뀐다**. Object를 생성하면 Data영역이 늘어나고, 함수를 호출하면 Stack이 늘어난다.  

프로세스는 "처음" 메모리에 등록될 때 자신의 메모리 영역이 결정된다. 초기 할당받은 영역을 넘어서는 메모리에 접근하려 하면 데이터가 **넘쳐 흐르게**된다. 이게 Stack Overflow다. 

### Thread

프로세스는 실행중인 프로그램이다. 한 프로세스는 여러 작업을 해야 할수도 있다. 프로세스 **내부**에서**독립적인 실행 흐름**을 **스레드**라고 한다. 프로세스는 시간의 흐름에 따라 해야 할 동작(실행흐름)이 있다. 그러므로 프로세스엔 무조건 하나 이상의 스레드가 있다.  
한 프로세스가 해야 할 일이 디스크에서 파일 가져오기, 키보드로 입력 받기, 음악 재생하기이고, 모두 동시에 이루어져야 한다고 생각해보자. 디스크에서 파일 가져오는것은 키보드로 입력 받는 것과 다른 실행흐름을 갖는다. 음악을 듣는 것은 디스크 파일 가져오기와 다른 흐름을 가진다. 이 세 작업을 하나의 흐름(싱글스레드)으로 처리하면 하나를 처리할 동안 다른 작업은 기다려야 한다. 세 작업을 각각의 흐름으로 처리하면(멀티스레드) 동시에 작업을 처리할 수 있다.  

아마도 지금껏 작성한 코드들은 싱글스레드일 것이다.(아마도?) 코드에서 반복문을 돌고 있을 동안 다음 줄은 실행되지 않는다. 어떤 작업을 하는 동안 다른 작업을 할 수 없다는 말이다. 멀티스레드 코드는 반복문을 수행하는 스레드, 다른 작업을 수행하는 스레드를 어떻게든 나누는 곳이 있다. 두 작업이 동시에 실행된다. 때문에 무엇이 먼저 실행될지 정확하게 알 수 없다.
이쯤되면 헷갈리는거 하나 더 나온다. 동시에 다른 작업을 한다고? 멀티프로세스와 멀티스레드는 뭐가 달라?  

프로세스는 **상호 독립적**이다. 프로세스끼리는 서로를 모른다. 모든 프로세스는 독립된 메모리 영역을 운영체제로부터 할당받는다. 멀티프로세스 작업 중에는 수행해야 할 작업인 프로세스의 메모리가 모두 다르므로, Code Data Stack 모두가 다르다. 컨텍스트 스위칭할 때 비워내야 할게 많다. 예컨대 똑같은 프로그램 3개를 동시에 실행한다고 가정하자. 이 프로그램은 어떤 파일을 읽어 모니터에 출력한다고 가정하자. 3개의 새로운 프로세스가 생길 것이다. 프로그램 정보는 같으므로 세 프로세스는 같은 일을 할 것이다. 동일한 파일이 필요하다. 세 프로세스중 하나가 파일 정보를 읽었으면 다른 프로세스와 공유하면 좋을 텐데 세 프로세스 모두 파일을 새로 열고 모니터에 출력한다. 프로세스는 **상호 독립적**이기 때문이다.

한 프로세스의 멀티스레드는 **Stack**만 다르고 나머지는 같다. 나머지 Code Data 영역은 같으므로 컨텍스트 스위칭 비용이 적다. 왜 Stack만 다를까? 실행흐름에 대한 정보가 Stack에 있기 때문이다. 즉 Stack이 다르면 실행흐름이 다르다. Stack이라는 자료구조를 생각하면 도움이 된다. 위 프로세스 예시와 비슷한 상황을 멀티스레드로 시뮬레이션해보자. 이번에는 **프로그램 3개**를 동시에 실행하는 것이 **아니라** **한 프로세스**에서 스레드 3개를 만든다고 생각한다. 음악 파일을 읽어 3가지 동작을 한다. 하나는 음악을 재생하고 하나는 가사를 출력하고 하나는 파일을 옮긴다. 셋 중 무엇이 먼저 실행될지 모르지만 먼저 실행하는 스레드가 파일 정보를 읽어들인다. 나머지 스레드는 파일 정보를 **공유**해서 각자 필요한 곳에 쓴다.  

같은 자원으로 동시에 무언가를 작업해야 한다. 멀티프로세스가 유리할까 멀티스레드가 유리할까? 멀티스레드가 훨씬 유리하다. 경우에 따라 수백 수천배, 그 이상 빠르기도 하다.

### PCB

운영체제도 프로세스일까? 맞다. 운영체제 역시 프로세스다. 하드디스크에 윈도우를 설치한다. 부팅하면서 윈도우를 메모리에 로드한다. 프로세스로 준비된 윈도우는 ~~CPU를 갈구기 시작한다..~~  
운영체제도 프로세스라면, 프로세스의 특징을 갖고 있겠군? 맞다. 커널 역시 메모리의 특정 영역을 사용하고, Code Data Stack을 갖고 있다. 좀 다른 점이라면 전원이 들어오는 순간 메모리로 로드하고 전원이 꺼질 때까지 메모리에 존재한다. 커널은 메모리의 제일 위(메모리 주소가 가장 낮은 위치)에 존재한다. 그럼 운영체제의 Data에는 무엇이 있을까? 

프로세스 관리를 위한 Process Control Block이 있다.  
![pcb](/assets/pcb.jpg)

> 이미지 출처: https://www.tutorialspoint.com/operating_system/os_processes.htm

운영체제가 프로세스를 관리하기 위해 갖고 있는 정보다. 운영체제는 이 PCB를 링크드 리스트로 관리하고 있다.  
Interrupt가 발생하거나 작업중인 프로세스가 종료되면, 운영체제는 CPU에게 다음 일을 시켜야 한다. 많은 프로세스가 서로 CPU를 달라고 조르고 있다. 운영체제는 누구에게 CPU 사용권을 줄지, 또 CPU에게 어떻게 프로세스를 넘겨줄지, PCB를 보고 판단한다.


프로세스에 대해 더 다룰 내용이 많지만, 나머지 내용은 CPU 스케줄링과 Memory Management때 같이 다룬다.

## CPU 스케줄링

윈도우라면 작업 관리자를 열어보자. 컨트롤 + 시프트 + ESC.  
맥OS라면 "시스템 정보"를 실행하자.
리눅스라면 터미널에 ps -A를 입력하자.

뭔가 많을 것이다. 화면에 보이는 것은 모두 프로세스다. 아무 작업을 실행하지 않아도 수많은 프로세스가 실행되고 있다.


